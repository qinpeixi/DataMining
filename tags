	Session.vim	/^map  ggVGY$/;"	m
	Session.vim	/^map!  ggVGY$/;"	m
	Session.vim	/^vmap  "+y$/;"	m
	Session.vim	/^map!  ,$/;"	m
	Session.vim	/^map!  zzi$/;"	m
c	Session.vim	/^nmap c :cs find c =expand("<cword>")$/;"	m
d	Session.vim	/^nmap d :cs find d =expand("<cword>")$/;"	m
e	Session.vim	/^nmap e :cs find e =expand("<cword>")$/;"	m
f	Session.vim	/^nmap f :cs find f =expand("<cfile>")$/;"	m
g	Session.vim	/^nmap g :cs find g =expand("<cword>")$/;"	m
i	Session.vim	/^nmap i :cs find i ^=expand("<cfile>")$/;"	m
s	Session.vim	/^nmap s :cs find s =expand("<cword>")$/;"	m
t	Session.vim	/^nmap t :cs find t =expand("<cword>")$/;"	m
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
05l	Session.vim	/^normal! 05l$/;"	m
08l	Session.vim	/^normal! 08l$/;"	m
<C-F2>	Session.vim	/^nnoremap <C-F2> :vert diffsplit $/;"	m
<C-F3>	Session.vim	/^map <C-F3> \\be  $/;"	m
<C-F5>	Session.vim	/^map <C-F5> :call CompileRunGcc()$/;"	m
<F12>	Session.vim	/^map <F12> gg=G$/;"	m
<F2>	Session.vim	/^nnoremap <F2> :g\/^\\s*$\/d$/;"	m
<F3>	Session.vim	/^map <F3> :tabnew .$/;"	m
<F5>	Session.vim	/^map <F5> :call Rungdb()$/;"	m
<F6>	Session.vim	/^map <F6> :call CompileC()$/;"	m
<F7>	Session.vim	/^map <F7> :tabp$/;"	m
<F8>	Session.vim	/^map <F8> :tabn$/;"	m
<F9>	Session.vim	/^nmap <silent> <F9> :Tlist$/;"	m
<Nul><Nul>c	Session.vim	/^nmap <Nul><Nul>c :vert scs find c =expand("<cword>")$/;"	m
<Nul><Nul>d	Session.vim	/^nmap <Nul><Nul>d :vert scs find d =expand("<cword>")$/;"	m
<Nul><Nul>e	Session.vim	/^nmap <Nul><Nul>e :vert scs find e =expand("<cword>")$/;"	m
<Nul><Nul>f	Session.vim	/^nmap <Nul><Nul>f :vert scs find f =expand("<cfile>")$/;"	m
<Nul><Nul>g	Session.vim	/^nmap <Nul><Nul>g :vert scs find g =expand("<cword>")$/;"	m
<Nul><Nul>i	Session.vim	/^nmap <Nul><Nul>i :vert scs find i ^=expand("<cfile>")$/;"	m
<Nul><Nul>s	Session.vim	/^nmap <Nul><Nul>s :vert scs find s =expand("<cword>")$/;"	m
<Nul><Nul>t	Session.vim	/^nmap <Nul><Nul>t :vert scs find t =expand("<cword>")$/;"	m
<Nul>c	Session.vim	/^nmap <Nul>c :scs find c =expand("<cword>")$/;"	m
<Nul>d	Session.vim	/^nmap <Nul>d :scs find d =expand("<cword>")$/;"	m
<Nul>e	Session.vim	/^nmap <Nul>e :scs find e =expand("<cword>")$/;"	m
<Nul>f	Session.vim	/^nmap <Nul>f :scs find f =expand("<cfile>")$/;"	m
<Nul>g	Session.vim	/^nmap <Nul>g :scs find g =expand("<cword>")$/;"	m
<Nul>i	Session.vim	/^nmap <Nul>i :scs find i ^=expand("<cfile>")$/;"	m
<Nul>s	Session.vim	/^nmap <Nul>s :scs find s =expand("<cword>")$/;"	m
<Nul>t	Session.vim	/^nmap <Nul>t :scs find t =expand("<cword>")$/;"	m
<Plug>NetrwBrowseX	Session.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)$/;"	m
Box_Muller	Vector.cpp	/^void Box_Muller(double rand_data[], size_t n)$/;"	f
C	LinearClassifier.hpp	/^    Vector C;$/;"	m	class:LinearClassifier
DaviesBouldinIndex	Kmeans.cpp	/^double Kmeans::DaviesBouldinIndex()$/;"	f	class:Kmeans
DunnIndex	Kmeans.cpp	/^double Kmeans::DunnIndex()$/;"	f	class:Kmeans
E	MLP.hpp	/^    Vector E;$/;"	m	class:MLP
GetEta	LinearClassifier.hpp	/^    double GetEta() { return eta; }$/;"	f	class:LinearClassifier
GetV	LinearClassifier.hpp	/^    Vector &GetV() { return V; }$/;"	f	class:LinearClassifier
GetVn	LinearClassifier.hpp	/^    double GetVn() { return vn; }$/;"	f	class:LinearClassifier
KAHANSUM_HPP	KahanSum.hpp	2;"	d
KEMANS_HPP	Kmeans.hpp	2;"	d
KMEAN	Kmeans.cpp	58;"	d	file:
KahanSum	KahanSum.hpp	/^    KahanSum():sum(0.0), c(0.0) {}$/;"	f	class:KahanSum
KahanSum	KahanSum.hpp	/^class KahanSum$/;"	c
Kmeans	Kmeans.cpp	/^Kmeans::Kmeans(list<Vector> &p, int K)$/;"	f	class:Kmeans
Kmeans	Kmeans.hpp	/^class Kmeans$/;"	c
LINEAR_CLASSIFIER_HPP	LinearClassifier.hpp	2;"	d
LinearClassifier	LinearClassifier.hpp	/^class LinearClassifier$/;"	c
MEDIAN_HPP	Median.hpp	2;"	d
MLP	MLP.cpp	/^MLP::MLP(int N, int K, double _eta)$/;"	f	class:MLP
MLP	MLP.hpp	/^class MLP$/;"	c
MLP_HPP	MLP.hpp	15;"	d
Median	Median.hpp	/^class Median$/;"	c
OJFRULE_HPP	OjaRule.hpp	2;"	d
OjaRule	OjaRule.hpp	/^    OjaRule(int N):m_N(N) {W.set_size(N);}$/;"	f	class:OjaRule
OjaRule	OjaRule.hpp	/^class OjaRule$/;"	c
SessionLoad	Session.vim	/^let SessionLoad = 1$/;"	v
TestMLP	test.cpp	/^void TestMLP(int n, int k, int times, double eta)$/;"	f
V	LinearClassifier.hpp	/^    Vector V;$/;"	m	class:LinearClassifier
V	MLP.hpp	/^    Vector *V;$/;"	m	class:MLP
VECTOR_HPP	Vector.hpp	2;"	d
Vector	Vector.cpp	/^Vector::Vector(const Vector &v)$/;"	f	class:Vector
Vector	Vector.cpp	/^Vector::Vector(size_t n)$/;"	f	class:Vector
Vector	Vector.hpp	/^    Vector() {}$/;"	f	class:Vector
Vector	Vector.hpp	/^class Vector$/;"	c
W	MLP.hpp	/^    Vector W;$/;"	m	class:MLP
W	OjaRule.hpp	/^    Vector W;$/;"	m	class:OjaRule
Y	MLP.hpp	/^    Vector Y;$/;"	m	class:MLP
Yp	MLP.hpp	/^    Vector Yp;$/;"	m	class:MLP
\	Session.vim	/^map <buffer> \\  :w$/;"	m
add	KahanSum.cpp	/^void KahanSum::add(double v)$/;"	f	class:KahanSum
add	Median.cpp	/^void Median::add(double value)$/;"	f	class:Median
add	Vector.cpp	/^void Vector::add(const Vector& v)$/;"	f	class:Vector
backward	MLP.cpp	/^void MLP::backward(const Vector &X, double c)$/;"	f	class:MLP
c	KahanSum.hpp	/^    double c, y, t;$/;"	m	class:KahanSum
classify	LinearClassifier.cpp	/^bool LinearClassifier::classify(const Vector &X) const$/;"	f	class:LinearClassifier
classify	MLP.cpp	/^bool MLP::classify(const Vector &X)$/;"	f	class:MLP
cluster_centers	Kmeans.hpp	/^    vector<Vector> cluster_centers;$/;"	m	class:Kmeans
clusterize	Kmeans.cpp	/^int Kmeans::clusterize()$/;"	f	class:Kmeans
colors	dataset1/show-clusters.py	/^colors = ('#FF4500', '#3CB371', '#4682B4', '#DB7093', '#FFD700')$/;"	v
data	Median.hpp	/^    std::vector<double> data;$/;"	m	class:Median
data	Vector.hpp	/^    vector<double> data;$/;"	m	class:Vector
debug	LinearClassifier.cpp	19;"	d	file:
dot	Vector.cpp	/^double Vector::dot(const Vector& v) const$/;"	f	class:Vector
eta	LinearClassifier.hpp	/^    double eta;$/;"	m	class:LinearClassifier
eta	MLP.hpp	/^    double eta;$/;"	m	class:MLP
eta	OjaRule.hpp	/^    double eta;$/;"	m	class:OjaRule
fi	Session.vim	/^nmap fi :!firefox %.html & $/;"	m
fill	Vector.cpp	/^void Vector::fill(double value)$/;"	f	class:Vector
forward	MLP.cpp	/^void MLP::forward(const Vector &X)$/;"	f	class:MLP
get	Vector.cpp	/^double Vector::get(int i) const$/;"	f	class:Vector
get_closest_center_id	Kmeans.cpp	/^int Kmeans::get_closest_center_id(const Vector &X)$/;"	f	class:Kmeans
get_cluster_center	Kmeans.hpp	/^    Vector get_cluster_center(int i) { return cluster_centers[i]; }$/;"	f	class:Kmeans
get_median	Median.cpp	/^double Median::get_median()$/;"	f	class:Median
get_point_id	Kmeans.hpp	/^    int get_point_id(int i) { return point_ids[i]; }$/;"	f	class:Kmeans
get_size	Vector.hpp	/^    size_t get_size() const { return n; }$/;"	f	class:Vector
get_sum	KahanSum.cpp	/^double KahanSum::get_sum()$/;"	f	class:KahanSum
gx	Session.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
inc_mul	Vector.cpp	/^void Vector::inc_mul(const Vector& v, double k)$/;"	f	class:Vector
init_point_indexes	Kmeans.cpp	/^void Kmeans::init_point_indexes()$/;"	f	class:Kmeans
k	Kmeans.hpp	/^    int k;$/;"	m	class:Kmeans
m_K	MLP.hpp	/^    int m_K;$/;"	m	class:MLP
m_N	MLP.hpp	/^    int m_N;$/;"	m	class:MLP
m_N	OjaRule.hpp	/^    int m_N;$/;"	m	class:OjaRule
main	dataset/show-points.py	/^def main():$/;"	f
main	dataset1/show-clusters.py	/^def main():$/;"	f
main	dataset1/show-points.py	/^def main():$/;"	f
main	test.cpp	/^int main(int argc, char *argv[])$/;"	f
max	Vector.cpp	/^double Vector::max() const$/;"	f	class:Vector
md	Session.vim	/^nmap md :!~\/.vim\/markdown.pl % > %.html $/;"	m
min	Vector.cpp	/^double Vector::min() const$/;"	f	class:Vector
mul	Vector.cpp	/^void Vector::mul(double k)$/;"	f	class:Vector
n	Vector.hpp	/^    size_t n;$/;"	m	class:Vector
norm	Vector.cpp	/^double Vector::norm() const$/;"	f	class:Vector
normalize	Vector.cpp	/^void Vector::normalize()$/;"	f	class:Vector
operator !=	Vector.cpp	/^bool Vector::operator != (const Vector &v)$/;"	f	class:Vector
operator =	Vector.cpp	/^Vector& Vector::operator = (const Vector &v)$/;"	f	class:Vector
operator ==	Vector.cpp	/^bool Vector::operator == (const Vector &v)$/;"	f	class:Vector
othogonalize	Vector.cpp	/^Vector& Vector::othogonalize(const Vector& v)$/;"	f	class:Vector
point_ids	Kmeans.hpp	/^    vector<int> point_ids;$/;"	m	class:Kmeans
points	Kmeans.hpp	/^    const list<Vector> &points;$/;"	m	class:Kmeans
print	MLP.cpp	/^void MLP::print()$/;"	f	class:MLP
printall	Vector.cpp	/^void Vector::printall(const char *title) const$/;"	f	class:Vector
read_data	Vector.cpp	/^void read_data(const char *fname, list<Vector>& data)$/;"	f
read_data	test.cpp	/^void read_data(const char *fname, vector<Vector> &data, vector<bool> &label)$/;"	f
read_data2	test.cpp	/^void read_data2(const char *fname, vector<Vector> &data)$/;"	f
reset	KahanSum.cpp	/^void KahanSum::reset()$/;"	f	class:KahanSum
reset	LinearClassifier.cpp	/^void LinearClassifier::reset(Vector &_C, size_t n, double _eta)$/;"	f	class:LinearClassifier
reset	MLP.cpp	/^void MLP::reset()$/;"	f	class:MLP
reset	Median.cpp	/^void Median::reset()$/;"	f	class:Median
s:cpo_save	Session.vim	/^let s:cpo_save=&cpo$/;"	v
s:l	Session.vim	/^let s:l = 355 - ((16 * winheight(0) + 10) \/ 21)$/;"	v
s:l	Session.vim	/^let s:l = 92 - ((3 * winheight(0) + 20) \/ 40)$/;"	v
s:so_save	Session.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:sx	Session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:wipebuf	Session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
set	Vector.cpp	/^void Vector::set(int i, double value)$/;"	f	class:Vector
set_hyperplane_weights	MLP.cpp	/^void MLP::set_hyperplane_weights(size_t i, Vector &C, const Vector &N)$/;"	f	class:MLP
set_size	Vector.hpp	/^    void set_size(size_t _n) { n = _n; data.resize(n);}$/;"	f	class:Vector
set_weights	LinearClassifier.cpp	/^void LinearClassifier::set_weights(const Vector &_C, const Vector &N)$/;"	f	class:LinearClassifier
signed_dist	LinearClassifier.cpp	/^double LinearClassifier::signed_dist(const Vector &X) const$/;"	f	class:LinearClassifier
square_norm	Vector.cpp	/^double Vector::square_norm() const$/;"	f	class:Vector
sub	Vector.cpp	/^void Vector::sub(const Vector& v)$/;"	f	class:Vector
sum	KahanSum.hpp	/^    double sum;$/;"	m	class:KahanSum
sum	Vector.cpp	/^double Vector::sum() const$/;"	f	class:Vector
t	KahanSum.hpp	/^    double c, y, t;$/;"	m	class:KahanSum
update	MLP.cpp	/^void MLP::update(const Vector &X, bool inClass)$/;"	f	class:MLP
update_centers	Kmeans.cpp	/^bool Kmeans::update_centers()$/;"	f	class:Kmeans
update_weights	LinearClassifier.cpp	/^void LinearClassifier::update_weights(const Vector &X, bool inSide)$/;"	f	class:LinearClassifier
vector_mean	Vector.cpp	/^Vector vector_mean(list<Vector>& data)$/;"	f
vector_median	Vector.cpp	/^Vector vector_median(list<Vector>& data)$/;"	f
vn	LinearClassifier.hpp	/^    double vn;$/;"	m	class:LinearClassifier
vn	MLP.hpp	/^    Vector vn;$/;"	m	class:MLP
wn	MLP.hpp	/^    double wn;$/;"	m	class:MLP
write_data	Kmeans.cpp	/^void Kmeans::write_data(const char *fname)$/;"	f	class:Kmeans
write_data	Vector.cpp	/^void write_data(const char *fname, list<Vector>& data)$/;"	f
write_data	test.cpp	/^void write_data(const char *fname, vector<Vector> &data, vector<bool> &label)$/;"	f
y	KahanSum.hpp	/^    double c, y, t;$/;"	m	class:KahanSum
z	MLP.hpp	/^    double z;$/;"	m	class:MLP
zo	Session.vim	/^normal zo$/;"	m
zp	MLP.hpp	/^    double zp;$/;"	m	class:MLP
zt	Session.vim	/^normal! zt$/;"	m
